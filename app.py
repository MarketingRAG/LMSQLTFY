from flask import Flask, request, jsonify, render_template, send_file
from flask_cors import CORS
import google.generativeai as genai
import os
from dotenv import load_dotenv
import pandas as pd
import plotly.express as px
import json
import re
from sqlalchemy import create_engine, text
import tempfile
import shutil
import subprocess
from pathlib import Path

# Load environment variables
load_dotenv()

app = Flask(__name__)
CORS(app)

# Configure Gemini
genai.configure(api_key=os.getenv('GOOGLE_API_KEY'))
model = genai.GenerativeModel('gemini-1.5-flash')

# Database connection
engine = create_engine(os.getenv('DATABASE_URL'))

def clean_sql_query(sql):
    # Remove triple backticks and optional 'sql' after them
    return re.sub(r"^```sql\s*|^```|```$", "", sql, flags=re.MULTILINE).strip()

def create_slidev_presentation(presentation_data):
    # Create a temporary directory for the presentation
    temp_dir = tempfile.mkdtemp()
    presentation_dir = Path(temp_dir) / 'presentation'
    presentation_dir.mkdir()
    
    # Create custom theme (minimal, just fonts/colors)
    theme_dir = presentation_dir / 'theme'
    theme_dir.mkdir()
    
    theme_css = """
    :root {
        --madison-ave-black: #1A1A1A;
        --pitch-deck-white: #FAFAFA;
        --big-idea-crimson: #C8102E;
        --ai-circuit-blue: #00B7FF;
        --cognac-gold: #D4A759;
    }
    body, .slidev-layout {
        font-family: 'GT America', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: var(--pitch-deck-white);
        color: var(--madison-ave-black);
    }
    .slidev-footer {
        color: var(--big-idea-crimson);
        font-weight: bold;
        font-size: 1.1em;
    }
    /* Minimal custom CSS, let UnoCSS handle spacing */
    """
    with open(theme_dir / 'style.css', 'w') as f:
        f.write(theme_css)
    
    # Create slides.md using Slidev/UnoCSS best practices for spacing
    canvas_width = 1280
    canvas_height = 720
    slides_content = f"""---
canvas:
  width: {canvas_width}
  height: {canvas_height}

theme: ./theme
background: https://source.unsplash.com/collection/94734566/1920x1080
class: text-center
highlighter: shiki
lineNumbers: false
title: {presentation_data['title']}
---

<div style="width: 100%; height: {canvas_height}px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
  <h1 style="font-family: 'GT America', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: var(--madison-ave-black); font-size: 4rem; font-weight: 700; margin-bottom: 1.2rem; letter-spacing: -0.02em;">
    {presentation_data['title']}
  </h1>
  <h2 style="font-family: 'GT America', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; color: var(--big-idea-crimson); font-size: 1.7rem; font-weight: 500; margin-top: 0; letter-spacing: 0.01em;">
    Generated by <span style='font-weight: 700;'>LMSQLTFY</span>
  </h2>
</div>
"""
    
    for i, slide in enumerate(presentation_data['slides'], 1):
        if slide['type'] == 'visualization':
            viz_path = presentation_dir / f'viz_{i}.html'
            with open(viz_path, 'w') as f:
                f.write(f"""
                <div id=\"viz\" style=\"width:100%;height:100%;\"></div>
                <script src=\"https://cdn.plot.ly/plotly-latest.min.js\"></script>
                <script>
                  const data = {slide['data']};
                  function renderPlot() {{
                    const layout = {{
                      autosize: true,
                      font: {{
                        family: 'GT America, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, sans-serif',
                        color: '#1A1A1A',
                        size: 16
                      }},
                      paper_bgcolor: '#FAFAFA',
                      plot_bgcolor: '#FAFAFA',
                      xaxis: {{
                        color: '#1A1A1A',
                        gridcolor: '#D4A759',
                        tickfont: {{ family: 'JetBrains Mono, monospace', color: '#1A1A1A' }},
                        tickangle: -45,
                        automargin: true
                      }},
                      yaxis: {{
                        color: '#1A1A1A',
                        gridcolor: '#D4A759',
                        tickfont: {{ family: 'JetBrains Mono, monospace', color: '#1A1A1A' }},
                        automargin: true
                      }},
                      margin: {{ t: 30, l: 50, r: 30, b: 80 }},
                    }};
                    const brandColors = ['#C8102E', '#00B7FF', '#D4A759'];
                    if (data.data) {{
                      data.data.forEach((trace, i) => {{
                        trace.marker = trace.marker || {{}};
                        trace.marker.color = brandColors[i % brandColors.length];
                        if(trace.type === 'line' || trace.type === 'scatter') {{
                          trace.line = trace.line || {{}};
                          trace.line.color = brandColors[i % brandColors.length];
                        }}
                      }});
                    }}
                    Plotly.newPlot('viz', data.data || data, layout, {{responsive: true, displayModeBar: false}});
                  }}
                  window.addEventListener('resize', renderPlot);
                  renderPlot();
                </script>
                """)
            slides_content += f"""
---
canvas:
  width: {canvas_width}
  height: {canvas_height}
layout: center
footer: Generated by LMSQLTFY
---

# {slide.get('question', 'Data Visualization')}

<div class=\"flex items-center justify-center w-full h-full min-h-full\" style=\"min-height: 100%;\">
  <div style=\"position: relative; width: 100%; max-width: 1280px; aspect-ratio: 16/9;\">
    <iframe src=\"viz_{i}.html\" style=\"position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; border-radius: 8px; background: #fafafa;\"></iframe>
  </div>
</div>

```sql
{slide['title']}
```
"""
    
    # Write slides.md
    with open(presentation_dir / 'slides.md', 'w') as f:
        f.write(slides_content)
    
    # Create package.json with custom theme
    package_json = {
        "name": "lmsqltfy-presentation",
        "private": True,
        "scripts": {
            "dev": "slidev",
            "build": "slidev build",
            "export": "slidev export"
        },
        "dependencies": {
            "@slidev/cli": "latest",
            "@slidev/theme-default": "latest",
            "@slidev/types": "^0.42.0"
        }
    }
    
    with open(presentation_dir / 'package.json', 'w') as f:
        json.dump(package_json, f, indent=2)
    
    return presentation_dir

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/chat', methods=['POST'])
def chat():
    try:
        data = request.json
        user_message = data.get('message', '')
        
        # Get database schema information
        with engine.connect() as connection:
            result = connection.execute(text("""
                SELECT table_name, column_name, data_type 
                FROM information_schema.columns 
                WHERE table_schema = 'public'
            """))
            schema_info = result.fetchall()
        
        # Create prompt for Gemini
        prompt = f"""Given the following database schema:
        {schema_info}
        
        User question: {user_message}
        
        Please provide a SQL query to answer this question. Only return the SQL query, nothing else."""
        
        # Get SQL query from Gemini
        response = model.generate_content(prompt)
        print("Gemini response:", response)  # For debugging
        
        # Try to extract the text from the response
        try:
            sql_query = response.candidates[0].content.parts[0].text.strip()
        except Exception as e:
            print("Error extracting SQL from Gemini response:", e)
            sql_query = None
        
        if not sql_query:
            raise Exception("Failed to extract SQL query from Gemini response.")
        
        print("SQL Query from Gemini:", sql_query)  # Debug print
        sql_query = clean_sql_query(sql_query)
        print("Cleaned SQL Query:", sql_query)  # Debug print
        
        # Execute the query
        df = pd.read_sql_query(sql_query, engine)
        print("Query result DataFrame:", df)
        
        # Filter out NaN results
        df = df.fillna(0)
        
        # Create visualization if appropriate
        visualization = None
        if len(df.columns) >= 2:
            # Determine the best chart type based on data characteristics
            x_col = df.columns[0]
            y_col = df.columns[1]
            
            # Check if we have a time series
            if pd.api.types.is_datetime64_any_dtype(df[x_col]):
                fig = px.line(df, x=x_col, y=y_col, title=f"{y_col} over time")
            
            # Check if we have categorical data
            elif df[x_col].nunique() <= 10 and not pd.api.types.is_numeric_dtype(df[x_col]):
                if len(df.columns) == 2:
                    # For 2 columns, use bar or pie chart
                    if df[y_col].sum() > 0:  # If we have positive values, use pie chart
                        fig = px.pie(df, names=x_col, values=y_col, title=f"Distribution of {y_col}")
                    else:
                        fig = px.bar(df, x=x_col, y=y_col, title=f"{y_col} by {x_col}")
                else:
                    # For multiple columns, use grouped bar chart
                    fig = px.bar(df, x=x_col, y=df.columns[1:], title=f"Multiple metrics by {x_col}")
            
            # Check if we have numeric data for scatter plot
            elif pd.api.types.is_numeric_dtype(df[x_col]) and pd.api.types.is_numeric_dtype(df[y_col]):
                if len(df.columns) > 2:
                    # If we have a third column, use it for color
                    color_col = df.columns[2]
                    fig = px.scatter(df, x=x_col, y=y_col, color=color_col, 
                                   title=f"{y_col} vs {x_col} colored by {color_col}")
                else:
                    fig = px.scatter(df, x=x_col, y=y_col, title=f"{y_col} vs {x_col}")
            
            # Default to bar chart if no other conditions are met
            else:
                fig = px.bar(df, x=x_col, y=y_col, title=f"{y_col} by {x_col}")
            
            # Update layout for better readability
            fig.update_layout(
                xaxis_title=x_col,
                yaxis_title=y_col,
                showlegend=True,
                legend_title="",
                template="plotly_white"
            )
            
            visualization = fig.to_json()
        
        print("Response JSON:", {
            'sql_query': sql_query,
            'data': df.to_dict(orient='records'),
            'visualization': visualization
        })
        return jsonify({
            'sql_query': sql_query,
            'data': df.to_dict(orient='records'),
            'visualization': visualization
        })
    except Exception as e:
        import traceback
        print("Exception:", e)
        traceback.print_exc()
        return jsonify({
            'error': str(e),
            'sql_query': None,
            'data': [],
            'visualization': None
        }), 500

@app.route('/api/presentation/view', methods=['POST'])
def view_presentation():
    try:
        presentation_data = request.json
        presentation_dir = create_slidev_presentation(presentation_data)
        
        # Install dependencies and start Slidev
        subprocess.run(['npm', 'install'], cwd=presentation_dir, check=True)
        subprocess.Popen(['npm', 'run', 'dev'], cwd=presentation_dir)
        
        return jsonify({
            'presentationUrl': 'http://localhost:3030'
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/presentation/export', methods=['POST'])
def export_presentation():
    try:
        presentation_data = request.json
        presentation_dir = create_slidev_presentation(presentation_data)
        
        # Install dependencies and export to PDF
        subprocess.run(['npm', 'install'], cwd=presentation_dir, check=True)
        subprocess.run(['npm', 'install', '--save-dev', 'playwright-chromium'], cwd=presentation_dir, check=True)
        subprocess.run(['npx', 'playwright', 'install', 'chromium'], cwd=presentation_dir, check=True)
        subprocess.run(['npm', 'run', 'export'], cwd=presentation_dir, check=True)
        
        # Send the PDF file
        pdf_path = presentation_dir / 'dist' / 'presentation.pdf'
        return send_file(
            pdf_path,
            mimetype='application/pdf',
            as_attachment=True,
            download_name='presentation.pdf'
        )
    except Exception as e:
        return jsonify({'error': str(e)}), 500
    finally:
        # Clean up temporary directory
        if 'presentation_dir' in locals():
            shutil.rmtree(presentation_dir.parent)

if __name__ == '__main__':
    app.run(debug=True) 